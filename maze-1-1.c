#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          LeftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          RightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int compass = 0; // 0 = N, 1 = E, 2 = S, 3 = W (given)
const int size = 35;
int compass_history[size] = {8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8};
int directions[size];
int i = 0;
int z = 0;
int current_coord[2] = {0,0}; //(given)
int target_coord[2] = {-2,-1}; //(given)
int val = 1525; //turn value : when in slippery maze, trun value 1500 else 1525
int speed = -100; //turn speed.

void TurnR(){ //turn right, update compass direction
	compass++;
	if (compass > 3)
		compass = 0;
	moveMotorTarget(LeftMotor,val, speed);
	moveMotorTarget(RightMotor,-val, -speed);
	waitUntilMotorStop(LeftMotor);
	waitUntilMotorStop(RightMotor);
}

void fix_orientation() {
	//move forward into the wall
	moveMotorTarget(LeftMotor,1000, speed);
	moveMotorTarget(RightMotor,1000, speed);
	waitUntilMotorStop(LeftMotor);
	waitUntilMotorStop(RightMotor);
	//move backward
	moveMotorTarget(LeftMotor,-500, -speed);
	moveMotorTarget(RightMotor,-500, -speed);
	waitUntilMotorStop(LeftMotor);
	waitUntilMotorStop(RightMotor);
}


void TurnL(){ //turn left, update compass direction
	compass--;
	if (compass < 0)
		compass = 3;
	moveMotorTarget(LeftMotor,-val, -speed);
	moveMotorTarget(RightMotor,val, speed);
	waitUntilMotorStop(LeftMotor);
	waitUntilMotorStop(RightMotor);
}
void MoveF(){ //move forward, update the history of movement directions, then update the coordinate we are at
	compass_history[i]=compass;
	moveMotorTarget(LeftMotor,2700, speed);
	moveMotorTarget(RightMotor,2700, speed);
	displayCenteredTextLine(3, "Compass: %d", compass); // %d is a format specifier for integers
	displayCenteredTextLine(4, "Coords: %d, %d", current_coord[0], current_coord[1]);


	i++;
	if (compass == 0){
		current_coord[1]++;
	}
	if (compass == 1){
		current_coord[0]++;
	}
	if (compass == 2){
		current_coord[1]--;
	}
	if (compass == 3){
		current_coord[0]--;
	}
	waitUntilMotorStop(LeftMotor);
	waitUntilMotorStop(RightMotor);

}

void MoveF_longer(){ //move forward, update the history of movement directions, then update the coordinate we are at
	compass_history[i]=compass;
	moveMotorTarget(LeftMotor,2700, speed);
	moveMotorTarget(RightMotor,2700, speed);
	displayCenteredTextLine(3, "Compass: %d", compass); // %d is a format specifier for integers
	displayCenteredTextLine(4, "Coords: %d, %d", current_coord[0], current_coord[1]);


	i++;
	if (compass == 0){
		current_coord[1]++;
	}
	if (compass == 1){
		current_coord[0]++;
	}
	if (compass == 2){
		current_coord[1]--;
	}
	if (compass == 3){
		current_coord[0]--;
	}
	waitUntilMotorStop(LeftMotor);
	waitUntilMotorStop(RightMotor);
}

bool DetectW(){ //detect the wall
	if (getUSDistance(S4) <= 10 || getUSDistance(S4) > 200){
		return true;

	}
	else
		return false;
}

task main()
{

	clearSounds();
	setSoundVolume(100);

	//playSoundFile("careless1.rsf");

	while(!(current_coord[0] == target_coord[0] && current_coord[1] == target_coord[1])){ //check if we are at the target coordinate, if so exit while
		TurnR();

		while (DetectW()) { // turn until there is no wall in the way
			fix_orientation();
			TurnL();
			displayCenteredTextLine(5, "Detecting Wall");
		}
		//if compass - compasshistory = 1, move forward is longer, else, move forward
		if((i != 0) /*&& (DetectW() == false)*/ && (compass_history[i-1] != compass)){
			displayCenteredTextLine(5, "No Wall");
			MoveF_longer();
		}
		else {
			displayCenteredTextLine(5, "No Wall");
			MoveF();
		}


	}

	for(int j=2;j<size-1;j++){ // iterate through the history of movements and cancel out opposite ones

		if (abs(compass_history[j] - compass_history[j+1]) == 2) {

			for (int k =j; k<size-k-1;k++){ //rewrite values to replace the cut out ones

				compass_history[k] = compass_history[k+2];

			}
			j -= 2; //move back two slots to check if the values cancel again
		}
	}

	for(int j=size-1;j>=0;j--){ // set the instruction array for the route back to the start, reversing each compass value to its opposite, and making the array backwards
		directions[size-(j+1)] = compass_history[j];
		if (directions[size-(j+1)] == 0)
			directions[size-(j+1)] = 2;
		else if (directions[size-(j+1)] == 1)
			directions[size-(j+1)] = 3;
		else if (directions[size-(j+1)] == 2)
			directions[size-(j+1)] = 0;
		else if (directions[size-(j+1)] == 3)
			directions[size-(j+1)] = 1;
		if (directions[size-(j+1)] == 8)
			directions[size-(j+1)] = 8;
	}

	//when sound plays, target destination has been reached
	playSoundFile("careless1.rsf");
	sleep(5000);
	//180 degree turn
	TurnL();
	TurnL();

	//starts to go back to its starting position
	for (int j = 0; j < size; j++) {
		// Check for 180-degree turns by comparing with opposite directions
		if (directions[j] == ((compass + 2) % 4)) {
			TurnL();
			if(DetectW())
				fix_orientation();
			TurnL();
			MoveF();

			} else if (directions[j] == compass) {
			MoveF();
			if(DetectW())
				fix_orientation();
			} else if (directions[j] == 8) {
			z++; // Ignore value
			} else if (directions[j] == ((compass + 1) % 4)) {
			TurnR();
			if(DetectW())
				fix_orientation();
			MoveF();

			} else if (directions[j] == ((compass - 1 + 4) % 4)) {
			TurnL(); // Adjust turning left to handle 4 directions
			if(DetectW())
				fix_orientation();
			MoveF();

		}

		//fix orientation is put at the beginning to prevent doing it once the destination is reached
		//fix orientation after 3 cells

	}

	//when sound plays, target destination has been reached
	playSoundFile("careless1.rsf");
	sleep(5000);
}
